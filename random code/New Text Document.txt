9i9def join_dataframes(jobs: pd.DataFrame, config: pd.DataFrame) -> pd.DataFrame:
    """
    Perform an inner join between jobs and config DataFrames. If the row count
    of the resulting DataFrame matches the row count of the config DataFrame,
    return the inner join result. Otherwise, return a full outer join result.

    Args:
        jobs (pd.DataFrame): The jobs DataFrame.
        config (pd.DataFrame): The config DataFrame.

    Returns:
        pd.DataFrame: The resulting DataFrame after the join operation.
    """
    # Perform inner join
    inner_join_df = jobs.merge(config, how='inner')

    # Check if row count matches config DataFrame
    if len(inner_join_df) == len(config):
        return inner_join_df

    # Perform full outer join if row counts don't match
    full_outer_join_df = jobs.merge(config, how='outer')
    return full_outer_join_df

import paramiko

def ssh_connect(host, port, username, password):
    """Establishes an SSH connection and returns the client."""
    try:
        client = paramiko.SSHClient()
        client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        client.connect(host, port=port, username=username, password=password)
        return client
    except Exception as e:
        print(f"SSH Connection Error: {e}")
        return None

def test_ssh_connection(client):
    """Runs 'ls' to test if the SSH connection is working."""
    try:
        stdin, stdout, stderr = client.exec_command("ls")
        output = stdout.read().decode().strip()
        if output:
            print("SSH connection successful. Listing directory contents:")
            print(output)
        else:
            print("SSH connection established, but 'ls' command returned no output.")
    except Exception as e:
        print(f"Error running 'ls': {e}")

def check_file_exists(client, file_path):
    """Checks if a specific file exists on the remote server."""
    try:
        stdin, stdout, stderr = client.exec_command(f'test -f "{file_path}" && echo "exists" || echo "not found"')
        result = stdout.read().decode().strip()
        return result == "exists"
    except Exception as e:
        print(f"Error checking file: {e}")
        return False

# Example usage
host = "your.server.com"
port = 22  # Change if needed
username = "your_username"
password = "your_password"
file_path = "/path/to/your/file.txt"

client = ssh_connect(host, port, username, password)
if client:
    test_ssh_connection(client)  # Run 'ls' to verify SSH is working
    
    if check_file_exists(client, file_path):
        print(f"File '{file_path}' exists!")
    else:
        print(f"File '{file_path}' does not exist.")
    
    client.close()







import paramiko

def ssh_connect_with_key(host, port, username, key_path):
    """Establishes an SSH connection using an SSH key."""
    try:
        key = paramiko.RSAKey(filename=key_path)
        client = paramiko.SSHClient()
        client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        client.connect(host, port=port, username=username, pkey=key)
        return client
    except Exception as e:
        print(f"SSH Connection Error: {e}")
        return None

# Example usage
host = "your.server.com"
port = 22  # Change if needed
username = "your_username"
key_path = "/path/to/your/private_key.pem"  # Replace with the actual path to your private key

client = ssh_connect_with_key(host, port, username, key_path)
if client:
    print("SSH connection successful!")
    client.close()






import subprocess

def ssh_command(host, username, command, key_path=None, port=22):
    """Executes an SSH command using subprocess."""
    ssh_cmd = ["ssh", "-p", str(port), f"{username}@{host}"]
    
    # Use SSH key authentication if a key path is provided
    if key_path:
        ssh_cmd.extend(["-i", key_path])
    
    ssh_cmd.append(command)

    try:
        result = subprocess.run(ssh_cmd, capture_output=True, text=True, check=True)
        return result.stdout.strip()
    except subprocess.CalledProcessError as e:
        print(f"SSH Command Error: {e.stderr}")
        return None

def test_ssh_connection(host, username, key_path=None, port=22):
    """Tests the SSH connection by listing directory contents."""
    print("Testing SSH connection...")
    output = ssh_command(host, username, "ls", key_path, port)
    if output is not None:
        print("SSH connection successful. Directory contents:")
        print(output)
    else:
        print("Failed to establish SSH connection.")

def check_file_exists(host, username, file_path, key_path=None, port=22):
    """Checks if a file exists on the remote server."""
    command = f'test -f "{file_path}" && echo "exists" || echo "not found"'
    result = ssh_command(host, username, command, key_path, port)
    return result == "exists"

# Example usage
host = "your.server.com"
port = 22
username = "your_username"
key_path = "/path/to/your/private_key.pem"  # Use None if no key file
file_path = "/path/to/your/file.txt"

# Test SSH connection
test_ssh_connection(host, username, key_path, port)

# Check if file exists
if check_file_exists(host, username, file_path, key_path, port):
    print(f"File '{file_path}' exists!")
else:
    print(f"File '{file_path}' does not exist.")
<<<<<<< HEAD
<<<<<<< HEAD
# Filtering based on conditions
filtered_result = df.loc[df['B'].eq("bacbl") & df['A'].str.contains("bb", na=False), 'C']

# Extract the first matched value safely
value = filtered_result.iloc[0] if not filtered_result.empty else None
=======
=======
>>>>>>> 9b60405eeed1496a61628e198fdd7cfce684a65d


import subprocess

def ssh_command(host, username, command, key_path=None, port=22):
    """Executes an SSH command using subprocess."""
    ssh_cmd = ["ssh", "-p", str(port), f"{username}@{host}"]
    
    if key_path:
        ssh_cmd.extend(["-i", key_path])
    
    ssh_cmd.append(command)

    try:
        result = subprocess.run(ssh_cmd, capture_output=True, text=True, check=True)
        return result.stdout.strip()
    except subprocess.CalledProcessError as e:
        print(f"SSH Command Error: {e.stderr}")
        return None

def check_files_exist(host, username, file_paths, key_path=None, port=22):
    """Checks if multiple files exist on the remote server."""
    results = {}

    for file_path in file_paths:
        command = f'test -f "{file_path}" && echo "exists" || echo "not found"'
        result = ssh_command(host, username, command, key_path, port)
        results[file_path] = (result == "exists")

    return results

# Example usage
host = "your.server.com"
port = 22
username = "your_username"
key_path = "/path/to/your/private_key.pem"  # Use None if no key file
file_paths = [
    "/path/to/file1.txt",
    "/path/to/file2.log",
    "/home/user/script.py"
]

# Check multiple files
file_statuses = check_files_exist(host, username, file_paths, key_path, port)

# Print results
for file, exists in file_statuses.items():
    print(f"{file}: {'Exists' if exists else 'Does not exist'}")


import pandas as pd

def get_unique_values(df: pd.DataFrame, column: str):
    """
    Returns a list of unique values in the specified column of the dataframe.

    :param df: Pandas DataFrame
    :param column: Column name as a string
    :return: List of unique values
    """
    if column in df.columns:
        return df[column].dropna().unique().tolist()
    else:
        raise ValueError(f"Column '{column}' not found in DataFrame")

# Example usage
data = {'A': [1, 2, 2, 3, 4, 4, None], 'B': ['x', 'y', 'y', 'z', 'x', None, 'z']}
df = pd.DataFrame(data)

print(get_unique_values(df, 'A'))  # Output: [1, 2, 3, 4]
print(get_unique_values(df, 'B'))  # Output: ['x', 'y', 'z']


import pandas as pd

def get_unique_values(df: pd.DataFrame, column: str, append_str: str = ''):
    """
    Returns a list of unique values in the specified column of the dataframe,
    with a given string appended to each value.

    :param df: Pandas DataFrame
    :param column: Column name as a string
    :param append_str: String to append to each unique value
    :return: List of unique values with the string appended
    """
    if column in df.columns:
        return [str(value) + append_str for value in df[column].dropna().unique()]
    else:
        raise ValueError(f"Column '{column}' not found in DataFrame")

# Example usage
data = {'A': [1, 2, 2, 3, 4, 4, None], 'B': ['x', 'y', 'y', 'z', 'x', None, 'z']}
df = pd.DataFrame(data)

print(get_unique_values(df, 'A', '_num'))  # Output: ['1_num', '2_num', '3_num', '4_num']
<<<<<<< HEAD
print(get_unique_values(df, 'B', '_str'))  # Output: ['x_str', 'y_str', 'z_str']
>>>>>>> 9b60405eeed1496a61628e198fdd7cfce684a65d
=======
print(get_unique_values(df, 'B', '_str'))  # Output: ['x_str', 'y_str', 'z_str']
>>>>>>> 9b60405eeed1496a61628e198fdd7cfce684a65d



# Filtering based on conditions
filtered_result = df.loc[df['B'].eq("bacbl") & df['A'].str.contains("bb", na=False), 'C']

# Extract the first matched value safely
value = filtered_result.iloc[0] if not filtered_result.empty else None

print(value)  # Output: 20






# Initialize session state for toggling the text box
if "show_textbox" not in st.session_state:
    st.session_state.show_textbox = False

# Button to toggle the text box visibility
if st.button("Show/Hide Text Box"):
    st.session_state.show_textbox = not st.session_state.show_textbox  # Toggle state

# Display text box if the button was clicked
if st.session_state.show_textbox:
    user_input = st.text_input("Enter some text:")
    st.write(f"You entered: {user_input}")  # Display user input



# Initialize session state to track clicks
if "selected_item" not in st.session_state:
    st.session_state.selected_item = None

# Define some items and their descriptions
items = {
    "Item A": "This is detailed information about Item A.",
    "Item B": "Here are some insights about Item B.",
    "Item C": "Item C has additional data displayed here."
}

# Create buttons for each item
for item, description in items.items():
    if st.button(item):
        st.session_state.selected_item = item  # Store the clicked item

# Display extra info if an item was clicked
if st.session_state.selected_item:
    st.text_area(
        "More Information",
        items[st.session_state.selected_item],
        height=100
    )